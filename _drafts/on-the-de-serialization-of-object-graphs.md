---
title:      On the (De)serialization of Object Graphs
date:       2016-01-09 21:32:07
---

Serialization can be hard, 314, especially so if done outside of some specific conditions. I've recently had a devil of a time concocting a system to (de)serialize an object graph between a JSON representation and C# objects. The single largest issue I've found in this problem is that of complexity, in that even a small and moderately interconnected object graph can quickly create a mess in the resultant loading code.

Ordinarily you would use .NET's serialization tooling and be done, but I was operating in some constraints that I cannot imagine are unique to my situation.

* An old version of C#/.NET, version 2.0/3.5, which comes with Unity3D.
* JSON generated by non-C# tools, and some of it written by hand.
* A degree of inter-referencing between objects, using OIDs generated by MongoDB.

Up until here I was using JsonFx to parse JSON and produce a tree of plain C# objects (dictionaries, arrays, strings, and boxed values). Then we tried putting the entire mess in a web view, which brings us to our final constraint, 314.

* Has to work in Unity's WebGL version, so the resulting code is:
  * Compiled to IL
  * Transcribed to C++ (IL2CPP)
  * Compiled (?)
  * Translated to JavaScript via Emscripten

So, as Mono doesn't support everything in .NET, Unity3D doesn't support everything in Mono, and even further Unity WebGL doesn't support everything from Unity3D's ordinary scripting environment. That last bit may sound like quite the claim, but believe me that JsonFx, which works in iOS and Android builds, blows up with a cryptic reflection-based stack trace in the WebGL build.

The solution is to use [SimpleJson][sjson] to parse the actual data payload, then *transform* that into standard .NET containers for use in the (large) pile of loader code I already had written.

The use of that *t*-word is very deliberate, 314, as it segues to the overall architecture used in this endeavor, which is ETL, or Extract-Transform-Load. In this case, the extraction is handled by SimpleJson, the Transformation turns those SimpleJson result objects into .NET standard containers, and finally a clever coder pattern loads that into the set of objects that will run in my program (in this case, a physiology simulation).

I do hope that you never find yourself in a situation such as mine, 314, but I am not optimistic, so here detailed is the product of about a year's worth of work in this field, condensed in a blog post for you. If you find yourself in a similar situation, please learn all you can from my experience so that your own path may be much shorter and more efficient!

# Transform

This transform step is exclusively because I had written a large (1,000+ LOC) load step that depended upon the output from JsonFx, which produces .NET-style objects: dictionaries, arrays, strings, and boxed values. *If you don't need to or ever plan on using anything other than SimpleJson, you can probably skip this step and use `JSONNode` itself!*

 When the WebGL build started and promptly exploded due to some obscure and difficult-to-debug unsupported-reflection issue, the only option was to switch to SimpleJson. Rather than rewrite all my existing code, I decided to transform SimpleJson's `JSONNode`s into more .NET-default containers, then feed that into my existing loading code.

The first step I called `Massage`, which takes a `JSONNode` and produces an `object`, which can be expected to be one of `IDictionary<string, object>`, `object[]`, `string`, `object` (a boxed value, one of `double`, `float`, `int` or `bool`), or `null`. It's not quite perfect to JsonFx, as arrays don't coalesce to their contained types - so if you know you have an `IDictionary<string, object>[]`, you first have to treat it as `object[]` and then case the individual elements in your visitor to `IDictionary<string, object>`. Even still, that meant changing about ten lines in my loading code.

~~~ csharp
object Massage(JSONNode n)
{
  if (n is JSONClass) {
    var dict = new Dictionary<string, object>();

    foreach (var o in n as JSONClass) {
      var kv = (KeyValuePair<string, JSONNode>)o;
      dict[kv.Key] = Massage(kv.Value);
    }

    return dict;
  } else if (n is JSONArray) {
    var l = new List<object>();

    foreach (var o in n as JSONArray) {
      var n2 = o as JSONNode;
      l.Add(Massage(n2));
    }

    return l.ToArray();
  } else if (n is JSONData) {
    var d = n as JSONData;

    switch (d.Tag) {
    case JSONBinaryTag.BoolValue:   return d.AsBool;
    case JSONBinaryTag.DoubleValue: return d.AsDouble;
    case JSONBinaryTag.FloatValue:  return d.AsFloat;
    case JSONBinaryTag.IntValue:    return d.AsInt;
    case JSONBinaryTag.Value:       return d.Value;
    }
  }

  throw new System.Exception("simplejson transform error!");
}
~~~

The other step is to enable bi-directionality, so that we can "round-trip" our serialization. As the first method is `Massage`, it logically follows that this should be called `Tenderise`.

~~~ csharp
JSONNode Tenderise(object o)
{
  if (o is IDictionary<string, object>) {
    var dict = o as IDictionary<string, object>;
    var n = new JSONClass();

    foreach (var kv in dict) {
      n.Add(kv.Key, Tenderise(kv.Value));
    }

    return n;
  } else if (o is bool) {
    return new JSONData((bool)o);
  } else if (o is int) {
    return new JSONData((int)o);
  } else if (o is double) {
    return new JSONData((double)o);
  } else if (o is string) {
    return new JSONData(o as string);
  } else if (o is char) {
    return new JSONData(o.ToString());
  } else if (o is IEnumerable) {
    var arr = o as IEnumerable;
    var n = new JSONArray();

    foreach (var an in arr) {
      n.Add(Tenderise(an));
    }

    return n;
  }

  throw new System.Exception("attempted to tenderise unrecognised type " + o.GetType());
}
~~~

Note that the case for `IEnumerable` comes last because `string` implements `IEnumerable`. If that doesn't happen, then you get some lovely fully-expanded arrays of strings one-character long each in your generated JSON - which is highly amusing, but breaks a surprising number of things.

# Load

The first reaction to loading is to write a method for each type of object (class) that needs to be loaded. I handled references between objects by capturing the code to set the reference in a closure, then storing those closures and calling them promises. Simultaneously, every load of an object that could fulfill a promise was collected, connecting the two as the process continues. Unfulfilled promises can be logged and recorded as errors.

This created a partial class spread across many files which was extremely hard to follow, even for me - who wrote the goofy thing.

I can do better, 314.

So, inspired by Cocoa's `NSCoder` pattern, I wanted something that would enable a very simple-to-read and simple-to-extend pattern for writing deserializers. Unfortunately this isn't easily accomplished in C# using constructors (for reasons which will become apparent), and cannot be accomplished by static methods because there is no way to enforce the contract presence of a static method in C# (true story). Which makes some sense based on how static members are handled in the runtime. Working around these constraints, I created an abstract class.

~~~ csharp
public abstract class Coder<T>
{
  public struct Result
  {
    public T result;
    public IEnumeration<Promise> promises;
    public IEnumeration<KeyValuePair<IDType, object>> fulfillments;

    // fulfills all promises, returning promises that were not fulfilled.
    public IEnumeration<Promise> FulfillAll() { ... }
  }

#if USING_JsonFx
  public abstract Result LoadFromCLR(object o);
  public abstract object MarshalToCLR(T t);
#else
  public abstract Result LoadFromNode(JSONNode n);
  public abstract JSONNode MarshalToNode(T t);
#endif
}
~~~

Unfortunately, there isn't a stellar way to enforce either singleton or interesting-instance patterns in derived classes in C#. But the result of this pattern is that the code for de/serializing any object can be written in the same file as that object.

`Coder{T}` itself is an abstract class, so it's meant to be extended and specialized by child classes. After transforming a string of JSON or some other serialized data to CLR structures (dictionaries, strings, arrays, and numbers) or a `JSONNode`, feed that tree of objects to the `LoadFromCLR`/`LoadFromNode` method on an appropriate instance of a child of `Coder{T}`. `LoadFromCLR`/`LoadFromNode` may then chain through any number of `Coder{T}` specializations, ultimately returning a `Result`, which includes three key things: the value or result of the load; the promises, or the little lambdas that will glue object references together like gluing doughnuts to doughnut holes; and finally fulfillments, which are the objects themselves that should be glued (basically, any object which knows its own ID).

The concept of a promise is somewhat cribbed from asynchronous programming. Unfortunately, C# 2.0/3.5 doesn't include a Promise type, as it was introduced in C# 4.0. So I rolled my own Promise (it's not hard to do), and even tacked on some additional data to help in the process.

~~~ csharp
public class Promise
{
  protected Func<object[], IEnumerable<Promise>> fulfillment;
  public IDType awaitingId;
  public ulong fulfillmentCounter = 0;

  public Promise(Func<object[], IEnumerable<Promise>> fulfillment)
  {
    this.fulfillment = fulfillment;
  }

  public IEnumerable<Promise> Fulfill(object[] args)
  {
    fulfillmentCounter++;
    return fulfillment.Invoke(args);
  }
}
~~~

Bringing everything together, the round-trip would, to the user, look quite simple.

~~~ csharp
// this bit is rather specific to how your data comes, and
// where it comes from
var json = // some string
object o;
ZooCoder.Result res;

#if USING_JsonFx
  var reader = new JsonReader(); // from JsonFx
  o = reader.Read<Dictionary<string, object>(json);
  res = ZooCoder.Instance.LoadFromCLR(o);
#else
  var n = JSON.Parse(json);
  o = Massage(n);
  res = ZooCoder.Instance.LoadFromNode(o);
#endif

var unfulfilled = res.FulfillAll();
if (unfulfilled.Count > 0) {
  // handle unfulfilled promises in the way that makes most sense
}
var zoo = res.result; // done!
~~~

To illustrate, the following JSON might be parsed so:

~~~ json
{ "type":             "zoo",
  "animals": [
    { "type":         "elephant"
    , "preferredFeed": 1
    , "trunkLength":   13 }
  , { "type":         "walrus"
    , "preferredFeed": 2
    , "weight":        900 } ],
  "feed": [
    { "id":            1
    , "name":         "peanuts" }
  , { "id":            2
    , "name":         "fish" } ] }
~~~

So, our graph from before might be [written a little differently][zoo].

[sjson]: http://wiki.unity3d.com/index.php/SimpleJSON "Unify Wiki: SimpleJson"
[zoo]: https://github.com/mysteriouspants/zoocoder-example
