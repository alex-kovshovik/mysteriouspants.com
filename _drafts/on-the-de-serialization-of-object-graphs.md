---
title:      On the (De)serialization of Object Graphs
date:       2016-01-09 21:32:07
---

Serialization can be hard, 314, especially so if done outside of some specific conditions. I've recently had a devil of a time concocting a system to (de)serialize an object graph between a JSON representation and C# objects. The single largest issue I've found in this problem is that of complexity, in that even a small and moderately interconnected object graph can quickly create a mess in the resultant loading code.

Ordinarily you would use .NET's serialization tooling and be done, but I was operating in some constraints that I cannot imagine are unique to my situation.

* An old version of C#/.NET, version 2.0/3.5, which comes with Unity3D.
* JSON generated by non-C# tools, and some of it written by hand.
* A degree of inter-referencing between objects, using OIDs generated by MongoDB.

Up until here I was using JsonFx to parse JSON and produce a tree of plain C# objects (dictionaries, arrays, strings, and boxed values). Then we tried putting the entire mess in a web view, which brings us to our final constraint, 314.

* Has to work in Unity's WebGL version, so the resulting code is:
  * Compiled to IL
  * Transcribed to C++ (IL2CPP)
  * Compiled (?)
  * Translated to JavaScript via Emscripten

So, as Mono doesn't support everything in .NET, Unity3D doesn't support everything in Mono, and even further Unity WebGL doesn't support everything from Unity3D's ordinary scripting environment. That last bit may sound like quite the claim, but believe me that JsonFx, which works in iOS and Android builds, blows up with a cryptic reflection-based stack trace in the WebGL build.

The solution is to use [SimpleJson][sjson] to parse the actual data payload, then *transform* that into standard .NET containers for use in the (large) pile of loader code I already had written.

The use of that *t*-word is very deliberate, 314, as it segues to the overall architecture used in this endeavor, which is ETL, or Extract-Transform-Load. In this case, the extraction is handled by SimpleJson, the Transformation turns those SimpleJson result objects into .NET standard containers, and finally a clever coder pattern loads that into the set of objects that will run in my program (in this case, a physiology simulation).

I do hope that you never find yourself in a situation such as mine, 314, but I am not optimistic, so here detailed is the product of about a year's worth of work in this field, condensed in a blog post for you. If you find yourself in a similar situation, please learn all you can from my experience so that your own path may be much shorter and more effecient!

# Transform

# Load


## The Naïve Approach

A naïve approach will see a multitude of functions, one for each type of
logical object in the graph. This is only frustrated by C#'s lack of
bare functions. They must be owned by an object, or be static to a
class.

    public class GraphRoot
    {
      public string sz1;
      public Node1[] n1s;
      public Node2 n2;
    }

    public class Node1 { public int i1; }
    public class Node2 { public double d1; }

    public class GraphLoader
    {
      public static GraphRoot LoadGraph(IDictionary<string, object> o)
      {
        return new GraphRoot
        {
          sz1 = o["sz1"] as string,
          n1s = (o["n1s"] as Dictionary<string, object>[])
            .Select(n1 => LoadNode1(n1).ToArray(),
          n2 = LoadNode2(o["n2"] as Dictionary<string, object>)
        };
      }

      public static Node1 LoadNode1(IDictionary<string, object> o)
      {
        return new Node1
        {
          i1 = Convert.ToInt(o["i1"])
        };
      }

      public static Node1 LoadNode2(IDictionary<string, object> o)
      {
        return new Node2
        {
          d1 = Convert.ToDouble(o["d1"]);
        };
      }
    }

For the most part, this approach is perfectly fine. It's simple and it
performs its job well. It breaks down, however, as more classes are
added. In other words, `GraphLoader` gets to be quite long, and I do not
like very long files, especially if they touch many different classes.
It becomes hard to follow.

A simple extension of this technique uses partial classes to break it up
into multiple files.

    // GraphLoader+LoadGraph.cs

    public partial class GraphLoader
    {
      public static GraphRoot LoadGraph(IDictionary<string, object> o)
      {
        ...
      }
    }

    // GraphLoader+LoadNode1.cs

    public partial class GraphLoader
    {
      public static Node1 LoadNode1(IDictionary<string, object> o)
      {
        ...
      }
    }

    // GraphLoader+LoadNode2.cs

    public partial class GraphLoader
    {
      public static Node2 LoadNode2(IDictionary<string, object> o)
      {
        ...
      }
    }

## Object References

By far the most maddening aspect of deserialization is reconstituting
references between objects. For simple has-one and has-many
relationships, it's trivial to reconstitute that reference as previously
shown. Non-parent-child relationships, however, are difficult to
reconstitute. Consider the following object graph:

    public class GraphRoot
    {
      public Node1[] n1s;
      public Node2[] n2s;
    }

    public class Node1
    {
      public Node2[] n2s;
    }

    public class Node2
    {
      public uint ui1;
    }

Any `Node2` can be considered a child of `GraphRoot` or of `Node1`,
though I should say that it is safer to consider it likely a child of
`GraphRoot`, just in case it is referenced by more than one `Node1`.

To unambiguously represent that graph in JSON (or any serialized data
format), `Node2` must be decorated with a unique ID. In my wanderings I
get that ID generated by MongoDB, though I do harbor dreams of using
integer IDs generated by PostgreSQL in the future. (I am not a fan of
MongoDB).

    public class Node2
    {
      public IDType id;
      public uint ui1;
    }

With this, we might represent the graph in JSON.

    { "n1s": [
        { "n2s": [ 1, 2 ] },
        { "n2s": [ 2, 3 ] } ],
      "n2s": [
        { "id": 1, "ui1": 7 },
        { "id": 2, "ui1": 5 },
        { "id": 3, "ui1": 3 } ] }

The second part of deserializing these references involves a promise
manager. When deserializing any reference to a node, it is entirely
possible that node being referenced hasn't been deserialized yet. Rather
than invent some mechanism of walking the graph to the appropriate data
site (if it exists!), instead I opted to use a "promise" to set that
data, by means of a lambda expression. These lambdas are collected in a
"promise manager."

    public class PromiseManager
    {
      private Dictionary<IDType, List<Func<object>>> promises =
        new Dictionary<IDType, List<Func<object>>>();
      private Dictionary<IDType, object> fulfillments =
        new Dictionary<IDType, object>();

      public void MakePromise(IDType t, Func<object> f)
      {
        if (fulfillments.HasKey(t)) {
          f.Invoke(fulfillments[t]);
        } else {
          if (!promises.HasKey(t)) {
            promises[t] = new List<Func<object>>();
          }

          promises[t].Add(f);
        }
      }

      public void FulfillPromise(IDType t, object o)
      {
        if (promises.HasKey(t)) {
          promises[t].Select(p => p.Invoke(o));
        }

        fulfillments[t] = o;
      }
    }

I think I named mine something inane, like `NaescentObjectManager`, to
scare coworkers away from trying to use it. But it created some really
very simple looking deserialization code.

    public class GraphLoader
    {
      private PromiseManager pm = new PromiseManager();

      public GraphRoot LoadGraphRoot(IDictionary<string, object> o)
      {
        return new GraphRoot
        {
          n1s = (o["n1s"] as Dictionary<string, object>[])
            .Select(n1 => LoadNode1(n1)).ToArray(),
          n2s = (o["n2s"] as Dictionary<string, object>[])
            .Select(n2 => LoadNode2(n2)).ToArray()
        };
      }

      public Node1 LoadNode1(IDictionary<string, object> o)
      {
        var n2s_ids = o["n2s"] as object[];
        var n2s_objects = new Node2[n2s_ids.Length];

        for (uint i = 0; i < n2s_ids.Length; i++) {
          var id = LoadIDType(n2s_ids[i]);
          pm.MakePromise(id, n2 => n2s_objects[i] = n2);
        }

        return new Node1
        {
          n2s = n2s_objects
        };
      }

      public Node2 LoadNode2(IDictionary<string, object> o)
      {
        var n2 = new Node2
        {
          id = LoadIDType(o["id"]),
          ui1 = Convert.ToUInt(o["ui1"])
        };

        pm.FulfillPromise(n2.id, n2);

        return n2;
      }

      public IDType LoadIDType(object o) { ... }
    }

Yet still I was unhappy. The deserialization file was long, it had a lot
of jumps between methods, and it wasn't very *functional*. If a
`GraphLoader` was used, perhaps on accident, to deserialize two
`GraphRoot`s, the old promises would persist in the promise manager,
creating strange bugs that are hard to diagnose.

We can do better, 314.

## Functional-style (De)serialization

Inspired in part by Cocoa's `NSCoder` pattern, I wanted something that
would enable a very simple-to-read and simple-to-extend pattern for
writing deserializers. So I created an abstract class.

    public abstract class Coder<T>
    {
      public struct Result
      {
        public T result;
        public IEnumeration<Promise> promises;
        public IEnumeration<KeyValuePair<IDType, object>> fulfillments;

        // fulfills all promises, returning promises that were not fulfilled.
        public IEnumeration<Promise> FulfillAll() { ... }
      }

      public abstract Result LoadFromCLR(object o);
      public abstract object MarshalToCLR(T t);
    }

Unfortunately, there isn't a stellar way to enforce either singleton or
interesting-instance patterns in derived classes in C#. But the result
of this pattern is that the code for de/serializing any object can be
written in the same file as that object.

`Coder{T}` itself is an abstract class, so it's meant to be extended and specialized by child classes. After transforming a string of JSON or some other serialized data to CLR structures (dictionaries, strings, arrays, and numbers), feed that tree of objects to the `LoadFromCLR` method on an appropriate instance of a child of `Coder{T}`. `LoadFromCLR` may then chain through any number of `Coder{T}` specializations, ultimately returning a `Result`, which includes three key things: the value or result of the load; the promises, or the little lambdas that will glue object references together; and finally fulfillments, which are the objects themselves that should be glued (basically, any object which knows its own ID).

The concept of a promise is somewhat cribbed from asynchronous programming. Unfortunately, C# 2.0/3.5 doesn't include a Promise type, as it was introduced in C# 4.0. So I rolled my own Promise (it's not hard to do), and even tacked on some additional data to help in the process.

    public class Promise
    {
      protected Func<object[], IEnumerable<Promise>> fulfillment;
      public IDType awaitingId;
      public ulong fulfillmentCounter = 0;
      public Promise(Func<object[], IEnumerable<Promise>> fulfillment)
      {
        this.fulfillment = fulfillment;
      }
      public IEnumerable<Promise> Fulfill(object[] args)
      {
        fulfillmentCounter++;
        return fulfillment.Invoke(args);
      }
    }

Bringing everything together, the round-trip would, to the user, look quite simple.

    // this bit is rather specific to how your data comes, and
    // where it comes from
    var json = // some string
    var reader = new JsonReader(); // from JsonFx
    var dict = reader.Read<Dictionary<string, object>(json);

    // this is what we've been discussing, 314!
    var res = GraphRootCoder.Instance.LoadFromCLR(dict);
    var unfulfilled = res.FulfillAll();
    if (unfulfilled.Count > 0) {
      ...
    }
    var graphRoot = res.result; // done!


So, our graph from before might be written a little differently.

    // IDType.cs

    public struct IDType : ulong { }

    // GraphRoot.cs

    public class GraphRoot
    {
      public Node1[] n1s;
      public Node2[] n2s;
    }

    public class GraphRootCoder : Coder<GraphRoot>
    {
      // convenience only - looks nicer than
      // (new GraphRootLoader()).LoadFromCLR()
      public static GraphRootLoader Instance
      { get { return new GraphRootLoader(); } }

      public override Result LoadFromCLR(object o)
      {
        if (o.GetType() != typeof(Dictionary<string, object>)) {
          ...
        }

        var dict = o as Dictionary<string, object>;
        var promises = new List<Promise>();
        var fulfillments = new List<KeyValuePair<IDType, object>>();

        var gr = new GraphRoot
        {
          n1s = o["n1s"].Select(n1_clr =>
          {
            var n1_r = Node1Coder.LoadFromCLR(n1_clr);
            promises.AddRange(n1_r.promises);
            fulfillments.AddRange(n1_r.fulfillments);
            return n1_r.result;
          }).ToArray(),
          n2s = o["n2s"].Select(n2_clr =>
          {
            var n2_r = Node2Coder.LoadFromCLR(n2_clr);
            promises.AddRange(n2_r.promises);
            fulfillments.AddRange(n2_r.fulfillments);
            return n2_r.result;
          }).ToArray()
        };

        return new Result
        {
          result = gr,
          promises = promises,
          fulfillments = fulfillments
        };
      }

      public override object MarshalToCLR(GraphRoot gr)
      {
        return new Dictionary<string, object>()
        {
          { "n1s", gr.n1s
                    .Select(n1 => Node1Coder.MarshalToCLR(n1))
                    .ToArray() },
          { "n2s", gr.n2s
                    .Select(n2 => Node2Coder.MarshalToCLR(n2))
                    .ToArray() }
        };
      }
    }

    // Node1.cs

    public class Node1
    {
      public Node2[] n2s;
    }

    // Node2.cs

    public class Node2
    {
      public IDType id;
      public uint ui1;
    }

[sjson]: http://wiki.unity3d.com/index.php/SimpleJSON "Unify Wiki: SimpleJson"
